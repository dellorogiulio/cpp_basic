/* 
 --- CLASSES PART 3 ---	
*/
#include <string>
#include <stdio.h>

/*
    CONSTRUCTORS
    Constructors are the way to build and initialize a class. They are fundamental part of a class since they are called everytime we need to
    create a new class instance.
    The build job consists in finding and reserving the proper amount of memory to store the attributes.
    The initialize job consists in filling the attributes with the proper value.
    
    Exist 2 (starting from C++11, 3) fundamental constructors:
    - default constructor: A default constructor is a constructor which can be called with no arguments (https://en.cppreference.com/w/cpp/language/default_constructor)
    - copy constructor: A copy constructor is constructor whose first parameter is T&‍, const T&‍, volatile T&‍, or const volatile T&‍, and either there are no other parameters,
                        or the rest of the parameters all have default values (https://en.cppreference.com/w/cpp/language/copy_constructor)
    (for sake of completeness, starting from C++11, - move constructor: https://en.cppreference.com/w/cpp/language/move_constructor which needs more concepts to be fully understood)

    The default constructor is implicitly (i.e. "under the hood") called every time a new class instance is built.
    The copy constructor is implicitly called every time a class instance is copied (i.e. a new instance is built and it's initialized to be a copy of the first one).

    It is important to keep in mind one important thing: the compiler has the ability and the freedom to define some constructors for us. 
    The rule is the following:
    - if NO user-defined constructor is defined, the a default constructor is generated by the compiler
    - if NO user-defined copy-constructor is defined, the copy-constructor is generated by the compiler
    (the rule for the move constructor is a little bit more complex, see the Implicitly-declared move constructor on https://en.cppreference.com/w/cpp/language/move_constructor )
*/

/* 
    More info:
    https://www.youtube.com/watch?v=BvR1Pgzzr38&t=1s
    https://www.youtube.com/watch?v=KMSYmY74AEs&list=PLE28375D4AC946CC3&index=4&t=647s (Strongly suggested)
 */

class Person
{
   private:
    std::string name_;
    std::string surname_;

   public:
    // user-defined default constructor
    Person() :
        name_(),   // here we call the default constructor of the attribute
        surname_()
    {
        puts("default constructor");
    }

    // user-defined copy constructor
    Person(const Person& other) :
        name_(other.name_),
        surname_(other.surname_)
    {
        puts("copy constructor");
    }

    std::string fullName() const { return name_ + " " + surname_; }
};

class AnotherPerson
{
   private:
    std::string name_;
    std::string surname_;

    /* No user-defined default and copy constructor -> defined by the compiler */
};

void getPersonByReference(const Person& person)
{
    // this function takes a Person as const reference -> NO COPY is performed
    // this function has access to the original 'person' and it can't modify it (since it takes it as a const&)
}

void getPersonByCopy(Person person)
{
    // this function takes a Person by VALUE and so the COPY constructor of 'Person' is called
    // this function has full access to this copy, it can modify it, but the original 'person' won't be modified in any way
 
    // In C and C++, every parameter passed to a function by value is copied to the stack:
    // to construct this copy, the copy constructor is ALWAYS called.
    // The job of copy constructor can be expensive (it depends on the class) and so.... use it only if necessary
}

void getAnotherPersonByCopy(AnotherPerson person)
{
    // this function takes an AnotherPerson by VALUE and so it calls the COPY constructor of 'AnotherPerson'
}

void usePerson()
{
    Person person;                 // call of default constructor -> this prints 'default constructor'
    getPersonByReference(person);  // -> no copy is performed, prints nothing
    getPersonByCopy(person);       // -> a copy is performed by calling the copy constructor -> prints 'copy constructor'

    AnotherPerson another_person;            // call of the compiler-generated default constructor
    getAnotherPersonByCopy(another_person);  // -> a copy is performed by calling the compiler-generated copy constructor
}

/*
    ASSIGNMENT OPERATOR
    Assignment operator is the function which is called when we use the operation =.
    This means that it's called when we assign a class instance to another, already existing. The most important assign operator is the copy-assignment operator
    (since C++11 the move-assignment operator exists too).
    The copy-assignment operator allows the left-hand side (lhs) of the assignment to become equal to the right-hand side (rhs)
    
    NOTE: lhs = rhs

    It is important to keep in mind one important thing: the compiler has the ability and the freedom to define the copy-assignment operator for us. 
    The rule is the following:
    - If NO user-defined copy assignment operators are provided, the copy-assignment operator is generated by the compiler
    (as before, some specific rules are needed: https://en.cppreference.com/w/cpp/language/move_assignment)
*/

namespace with_assignment
{
class Person
{
   private:
    std::string name_;
    std::string surname_;

   public:
    Person& operator=(const Person& other)  // note the syntax for a copy-assignment operator declaration:
                                            // it returns a reference to Person
                                            // is written operator= (in general, operator[SIGN])
                                            // takes exactly one argument of type const Person&
    {
        if (&other != this)  // check that we are not assigning to ourself
        {
            puts("copy assignment");
            name_ = other.name_;
            surname_ = other.surname_;
        }
        else
        {
            puts("self assignment: doing nothing");
        }
        return *this;  // we return a reference to ourself
    }

    std::string fullName() const { return name_ + " " + surname_; }
};

class AnotherPerson
{
   private:
    std::string name_;
    std::string surname_;

    /* No user-defined copy-assignment operator -> defined by the compiler */
};

void assignPerson()
{
    Person person1;
    Person person2;
    person1 = person2;  // -> call of the copy-assignment operator, prints 'copy assignment'
 
    person1 = person1;  // -> call of the copy-assignment operator to handle self-assignment, prints 'self assignment: doing nothing'
                        // self-assignment seems a stupid example, but it's not. It's completely legal C++ code and so every copy-assignment operator
                        // MUST work as expected (doing nothig, without hidden issues) in the case of self-assignemt.
                        // Believe me, this is not so easy; bu we need other concepts to clarify it.
 
    AnotherPerson another_person1;
    AnotherPerson another_person2;
    another_person1 = another_person2;  // -> call of the compiler-generated copy-assignment operator, prints nothing
}

}  // namespace with_assignment

int main()
{
    usePerson();
    with_assignment::assignPerson();
}
